@document.meta
title: lacyn
description: Last Algorithms Course You'll Need
categories: CS
@end

{https://frontendmasters.com/courses/algorithms}[Course URL]

* Big O Time Complexity
** What is it?
	 - categorize algorithm's time or memory requirements based on input
	 - not supposed to be an exact measurement
	 - meant to generalize the growth of your algorithm
** How to calculate it?
	 - Look for loops
	 - ignore constants
	 - always take worst case (upper bound "Big O")
** Examples
	 - O(1): constant time (does not grow with input)
	 - O(logn): {** Binary Search}
	 - o(n^1/2): {** Crystal Ball Challenge}
	 - O(n): {** Linear Search}
	 - O(nlogn): quicksort
	 - O(n^2): nested for loop (n^3 would be 3 nested for loops)
	 - O(2^n):
	 - O(n!):
** Key Takeaways
	 - growth with respect to the input
	 - constants are dropped
	 - worst case is /usually/ the way we measure

* Array Data Structure
** What is it?
	 - contingous memory space
	 - needs to have a /specific/ type associated with it
** How does insertion work?
	 - go to address + width * offset (constant time)
	 - don't insert, but overwrite (no allocation)
	 - don't delete, but set to zero or sentinal value (no deallocation)
** Key Takeaways
	 - They are fixed size, contingous memory chunks
	 -- which means you cannot grow it (only reallocate into new array)
	 -- there is no "insertAt" or push/pop

* Search
** Linear Search
	 - simplest form of search: O(n)
	 - walk over an array and check if `i_val == val`

	 @code typescript
function linear_fn(haystack: number[], needle: number): boolean {
    for (let i = 0; i < haystack.length; ++i) {
        if (haystack[i] == needle) {
            return true;
        }
    }
    return false;
	@end

** Binary Search
	 - requires that the array is *sorted*
	 - halve the array each step: O(logn)

	 @code typescript
function binary_fn(haystack: number[], needle: number): boolean {
    let lo = 0;
    let hi = haystack.length;

    do {
        const m = Math.floor(lo + (hi - lo) / 2);
        const v = haystack[m];
        if (v == needle) {
            return true;
        }
        if (v > needle) {
            hi = m;
        } else {
            lo = m + 1;
        }
    } while (lo < hi);

    return false;
}
	 @end

** Crystal Ball Challenge
	 - requires that we jump square root of n: 0(n^1/2)
	 - makes it so that we do not need to search in linear time

	 @code typescript
function two_crystal_balls(breaks: boolean[]): number {
    const jumpAmount = Math.floor(Math.sqrt(breaks.length));

    let lastJump = 0;
    let currentIndex = jumpAmount;

    do {
        if (breaks[currentIndex] === true) {
            // walk square root of n until we break
            for (let i = lastJump + 1; i <= currentIndex; i++) {
                if (breaks[i] == true) {
                    return i;
                }
            }
        } else {
            lastJump = currentIndex;
            currentIndex += jumpAmount;
        }
    } while (currentIndex < breaks.length);

    return -1;
	 @end
